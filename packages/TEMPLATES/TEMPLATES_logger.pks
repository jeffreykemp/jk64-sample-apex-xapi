create or replace PACKAGE TEMPLATES AS
/*******************************************************************************
 Code templates used by GENERATE - Logger version
 09-FEB-2016 Jeffrey Kemp
 Each template starts with <%TEMPLATE [name]> and ends with <%END TEMPLATE>
 For syntax, refer to:
 https://bitbucket.org/jk64/jk64-sample-apex-tapi/wiki/Template%20Syntax
 Note: no package body is required.
 Warning: don't put # at start of a line or it may fail in SQL*Plus.
*******************************************************************************/

JOURNAL_TAB_SUFFIX  CONSTANT VARCHAR2(30) := '$JN';
JOURNAL_TRG_SUFFIX  CONSTANT VARCHAR2(30) := '$TRG';
TAPI_SUFFIX         CONSTANT VARCHAR2(30) := '$TAPI';
APEXAPI_SUFFIX      CONSTANT VARCHAR2(30) := '$APEX';
TEMPLATE_SUFFIX     CONSTANT VARCHAR2(30) := '$GEN';
LOV_VW_SUFFIX       CONSTANT VARCHAR2(30) := '_VW';

-- column lists
AUDIT_COLUMNS_LIST     CONSTANT VARCHAR2(100) := 'CREATED_DT,CREATED_BY,LAST_UPDATED_DT,LAST_UPDATED_BY';
GENERATED_COLUMNS_LIST CONSTANT VARCHAR2(100) := AUDIT_COLUMNS_LIST||',VERSION_ID';

LOB_DATATYPES_LIST     CONSTANT VARCHAR2(100) := 'BLOB,BFILE,CLOB,NCLOB,XMLTYPE';

--avoid compilation of the template code
$if false $then
--(these borders are just to visually separate the templates, they're not significant)
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

-- This journal trigger performs reasonably well for bulk inserts/updates/
-- deletes by keeping the changed records in a small array and flushing only
-- after 100 records. The number 100 is a compromise between not allowing too
-- many concurrent sessions from using lots of memory, while not doing too many
-- small-array inserts into the journal table.
-- In the degenerate case (where the application is doing single-row DML) it
-- adds only minimal overhead.
<%TEMPLATE CREATE_JOURNAL_TRIGGER>
CREATE OR REPLACE TRIGGER <%TRIGGER>
  FOR INSERT OR UPDATE OR DELETE ON <%TABLE>
  <%IF SECURITY_CONTEXT>WHEN (SYS_CONTEXT('<%CONTEXT>','<%TRIGGER>') IS NULL)<%END IF>
  COMPOUND TRIGGER
/*******************************************************************************
 Journal Trigger - DO NOT EDIT
 <%SYSDATE> - Generated by <%USER>
*******************************************************************************/

  FLUSH_THRESHOLD CONSTANT SIMPLE_INTEGER := 100;
  TYPE jnl_t IS TABLE OF <%JOURNAL>%ROWTYPE
    INDEX BY SIMPLE_INTEGER;
  jnls jnl_t;

  PROCEDURE flush_array (arr IN OUT jnl_t) IS
  BEGIN
    FORALL i IN 1..arr.COUNT
      INSERT INTO <%JOURNAL> VALUES arr(i);
    arr.DELETE;
  END flush_array;

  BEFORE EACH ROW IS
  BEGIN
    <%IF SECURITY_CONTEXT><%ELSE>IF <%TAPI>.journal_trigger_enabled THEN<%END IF>
      IF UPDATING THEN
        :NEW.last_updated_by := NVL(<%CONTEXT_APP_USER>,USER);
        :NEW.last_updated_dt := SYSDATE;
        :NEW.version_id      := :OLD.version_id + 1;
      END IF;
    <%IF SECURITY_CONTEXT><%ELSE>END IF;<%END IF>
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
    r <%JOURNAL>%ROWTYPE;
  BEGIN
    <%IF SECURITY_CONTEXT><%ELSE>IF <%TAPI>.journal_trigger_enabled THEN<%END IF>
      IF INSERTING OR UPDATING THEN
        <%COLUMNS INCLUDING VIRTUAL>
        r.#col#... := :NEW.#col#;~
        <%END>
        IF INSERTING THEN
          r.jn$action := 'I';
        ELSIF UPDATING THEN
          r.jn$action := 'U';
        END IF;
      ELSIF DELETING THEN
        <%COLUMNS INCLUDING VIRTUAL>
        r.#col#... := :OLD.#col#;~
        <%END>
        r.jn$action := 'D';
      END IF;
      r.jn$timestamp := SYSTIMESTAMP;
      r.jn$action_by := NVL(<%CONTEXT_APP_USER>,USER);
      jnls(NVL(jnls.LAST,0) + 1) := r;
      IF jnls.COUNT >= FLUSH_THRESHOLD THEN
        flush_array(arr => jnls);
      END IF;
    <%IF SECURITY_CONTEXT><%ELSE>END IF;<%END IF>
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    flush_array(arr => jnls);
  END AFTER STATEMENT;

END <%TRIGGER>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE TAPI_PACKAGE_SPEC>
CREATE OR REPLACE PACKAGE <%TAPI> AS
/*******************************************************************************
 Table API for <%TABLE>
 <%SYSDATE> - Generated by <%USER>
 Note: custom code for this table may be compiled in package <%TEMPLATE>. 
*******************************************************************************/

/******************************* USAGE NOTES ***********************************
 Only call the single-row methods when only one row needs to be processed.
 Always call the bulk methods when more than one row needs to be processed.

 If a method is not perfectly suited to the task at hand (e.g. you want to
 update just two columns but all we have is a "update everything!" method),
 add a new one.

 Don't call a "get" function if you need to then correlate the results
 from other "get" functions - instead, put all the logic into a view.
*******************************************************************************/

CURSOR cur IS
  SELECT x.*
        ,x.ROWID AS "ROWID"
  FROM   <%table> x;
SUBTYPE rowtype IS cur%ROWTYPE;
TYPE arraytype IS TABLE OF rowtype INDEX BY BINARY_INTEGER;

TYPE rvtype IS RECORD
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... VARCHAR2(4000)~
   #col#... <%table>.#col#%TYPE{ID}~
   #col#... <%table>.#col#%TYPE{BLOB}~
   #col#... <%table>.#col#%TYPE{CLOB}~
   #col#... <%table>.#col#%TYPE{XMLTYPE}~
   #col#... VARCHAR2(20){ROWID}~
   #col#... VARCHAR2(1){EVENTS.REPEAT_IND}~
  ,<%END>
  );
TYPE rvarraytype IS TABLE OF rvtype INDEX BY BINARY_INTEGER;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_SPEC_DEC>

PROCEDURE append_params
  (params IN OUT logger.tab_param
  ,r      IN rowtype);

PROCEDURE append_params
  (params IN OUT logger.tab_param
  ,rv     IN rvtype);

-- return a rowtype with the given values
FUNCTION rec
  (<%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
   #col#... IN <%table>.#col#%TYPE... := NULL~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rowtype;

-- return an rvtype with the given values
FUNCTION rv
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... IN VARCHAR2 := NULL~
   #col#... IN <%table>.#col#%TYPE... := NULL{ID}~
   #col#... IN <%table>.#col#%TYPE... := NULL{LOB}~
   #col#... IN VARCHAR2 := NULL{EVENTS.REPEAT_IND}~
  ,<%END>
  ) RETURN rvtype;

-- return a mapping of column name -> user-friendly label
FUNCTION label_map RETURN UTIL.str_map;

-- validate the row (returns an error message if invalid)
FUNCTION val (rv IN rvtype) RETURN VARCHAR2;

-- insert a row
FUNCTION ins (rv IN rvtype) RETURN rowtype;

-- insert multiple rows, array may be sparse; returns no. records inserted
FUNCTION bulk_ins (arr IN rvarraytype) RETURN NUMBER;

-- update a row
FUNCTION upd (rv IN rvtype) RETURN rowtype;

-- update multiple rows, array may be sparse; returns no. records updated
FUNCTION bulk_upd (arr IN rvarraytype) RETURN NUMBER;

-- delete a row
PROCEDURE del (rv IN rvtype);

-- delete multiple rows; array may be sparse; returns no. records deleted
FUNCTION bulk_del (arr IN rvarraytype) RETURN NUMBER;

-- convert an rvtype to a rowtype
FUNCTION to_rowtype (rv IN rvtype) RETURN rowtype;

-- convert a rowtype to an rvtype
FUNCTION to_rvtype (r IN rowtype) RETURN rvtype;

-- get a row (raise NO_DATA_FOUND if not found)
FUNCTION get (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
              #col#... IN <%table>.#col#%TYPE~
              p_#col# IN VARCHAR2{ROWID}~
              #col#... IN <%table>.#col#%TYPE := NULL{VERSION_ID}~
             ,<%END>
             ,as_at IN TIMESTAMP := NULL) RETURN rowtype;

-- convert to a copy
FUNCTION copy (r IN rowtype) RETURN rowtype;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_SPEC_METHODS>

-- concatenate to a single string
FUNCTION to_string
  (r   IN rowtype
  ,sep IN VARCHAR2 := '|'
  ) RETURN CLOB;

<%IF DBMS_CRYPTO>
-- generate a hash for the record
FUNCTION hash (r IN rowtype) RETURN VARCHAR2;
<%END IF>

-- Use these procedures to disable and re-enable the journal trigger just for
-- this session (to disable for all sessions, just disable the database trigger
-- instead).
PROCEDURE disable_journal_trigger;
PROCEDURE enable_journal_trigger;
FUNCTION journal_trigger_enabled RETURN BOOLEAN;

END <%TAPI>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE TAPI_PACKAGE_BODY>
CREATE OR REPLACE PACKAGE BODY <%TAPI> AS
/*******************************************************************************
 Table API for <%TABLE>
 <%SYSDATE> - Generated by <%USER>
 Note: custom code for this table may be compiled in package <%TEMPLATE>. 
*******************************************************************************/

scope_prefix constant varchar2(31) := lower($$plsql_unit) || '.';

-- column name constants
<%COLUMNS EXCLUDING GENERATED>
C_#COL28#... CONSTANT VARCHAR2(30) := '#COL#';~
<%END>

<%IF SECURITY_CONTEXT><%ELSE>g_trigger_disabled BOOLEAN;<%END IF>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_DEC>

PROCEDURE lost_upd (rv IN rvtype) IS
  scope              logger_logs.scope%type := scope_prefix || 'lost_upd';
  params             logger.tab_param;
  db_last_updated_by <%table>.last_updated_by%TYPE;
  db_last_updated_dt <%table>.last_updated_dt%TYPE;
BEGIN
  append_params (params, rv);
  logger.log('START', scope, null, params);

  SELECT x.last_updated_by
        ,x.last_updated_dt
  INTO   db_last_updated_by
        ,db_last_updated_dt
  FROM   <%table> x
  WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
         x.#col#... = rv.#col#~
  AND    <%END>;

  UTIL.raise_lost_update
    (updated_by => db_last_updated_by
    ,updated_dt => db_last_updated_dt
    ,scope      => scope
    ,params     => params);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    UTIL.raise_error('LOST_UPDATE_DEL', scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END lost_upd;

/*******************************************************************************
                               PUBLIC INTERFACE
*******************************************************************************/

PROCEDURE append_params
  (params IN OUT logger.tab_param
  ,r      IN rowtype) IS
BEGIN
  <%COLUMNS INCLUDING ROWID>
  logger.append_param(params, 'r.#col#',... r.#col#);~
  logger.append_param(params, 'r.#col#.len',... dbms_lob.getlength(r.#col#));{LOB}~
  <%END>
END append_params;

PROCEDURE append_params
  (params IN OUT logger.tab_param
  ,rv     IN rvtype) IS
BEGIN
  <%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
  logger.append_param(params, 'rv.#col#',... rv.#col#);~
  logger.append_param(params, 'rv.#col#.len',... dbms_lob.getlength(rv.#col#));{LOB}~
  <%END>
END append_params;

FUNCTION rec
  (<%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
   #col#... IN <%table>.#col#%TYPE... := NULL~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rowtype IS
  scope  logger_logs.scope%type := scope_prefix || 'rec';
  params logger.tab_param;
  r      rowtype;
BEGIN
  logger.log('START', scope, null, params);
  
  <%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
  r.#col#... := #col#;~
  <%END>

  append_params(params, r);
  logger.log('END', scope, null, params);
  RETURN r;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END rec;

-- return an rvtype with the given values
FUNCTION rv
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... IN VARCHAR2 := NULL~
   #col#... IN <%table>.#col#%TYPE... := NULL{ID}~
   #col#... IN <%table>.#col#%TYPE... := NULL{LOB}~
   #col#... IN VARCHAR2 := NULL{EVENTS.REPEAT_IND}~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rvtype IS
  scope  logger_logs.scope%type := scope_prefix || 'rv';
  params logger.tab_param;
  rv     rvtype;
BEGIN
  logger.log('START', scope, null, params);

  <%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
  rv.#col#... := #col#;~
  <%END>

  append_params(params, rv);
  logger.log('END', scope, null, params);
  RETURN rv;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END rv;

FUNCTION label_map RETURN UTIL.str_map IS
  scope logger_logs.scope%type := scope_prefix || 'label_map';
  params  logger.tab_param;
  lm      UTIL.str_map;
BEGIN
  logger.log('START', scope, null, params);

  <%COLUMNS EXCLUDING GENERATED>
  lm(C_#COL28#)... := '#Label#';~
  <%END>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_LABEL_MAP>

  logger.log('END', scope, null, params);
  RETURN lm;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END label_map;

FUNCTION val (rv IN rvtype) RETURN VARCHAR2 IS
  -- Validates the record but without reference to any other rows or tables
  -- (i.e. avoid any queries in here).
  -- Unique and referential integrity should be validated via suitable db
  -- constraints (violations will be raised when the ins/upd/del is attempted).
  -- Complex cross-record validations should usually be performed by a XAPI
  -- prior to the call to the TAPI.
  scope  logger_logs.scope%type := scope_prefix || 'val';
  params logger.tab_param;
BEGIN
  append_params(params, rv);
  logger.log('START', scope, null, params);

  <%COLUMNS EXCLUDING NULLABLE,GENERATED,SURROGATE_KEY,IDENTITY,LOBS,DEFAULT_ON_NULL>
  UTIL.val_not_null (val => rv.#col#, column_name => C_#COL28#);~
  <%END>
  <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY,IDENTITY,LOBS>
  UTIL.val_ind (val => rv.#col#, column_name => C_#COL28#);{IND}~
  UTIL.val_yn (val => rv.#col#, column_name => C_#COL28#);{YN}~
  UTIL.val_code (val => rv.#col#, column_name => C_#COL28#);{CODE}~
  UTIL.val_max_len (val => rv.#col#, len => #MAXLEN#, column_name => C_#COL28#);{VARCHAR2}~
  UTIL.val_numeric (val => rv.#col#, column_name => C_#COL28#);{NUMBER}~
  UTIL.val_date (val => rv.#col#, column_name => C_#COL28#);{DATE}~
  UTIL.val_datetime (val => rv.#col#, column_name => C_#COL28#);{DATETIME}~
  UTIL.val_timestamp (val => rv.#col#, column_name => C_#COL28#);{TIMESTAMP}~
  UTIL.val_timestamp_tz (val => rv.#col#, column_name => C_#COL28#);{TIMESTAMP_TZ}~
  ~
  <%END>
  
<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_VAL>

  logger.log('END', scope, null, params);
  RETURN UTIL.first_error;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END val;

PROCEDURE bulk_val (arr IN rvarraytype) IS
  scope     logger_logs.scope%type := scope_prefix || 'bulk_val';
  params    logger.tab_param;
  i         BINARY_INTEGER;
  error_msg VARCHAR2(32767);
BEGIN
  logger.append_param(params, 'arr.COUNT', arr.COUNT);
  logger.log('START', scope, null, params);

  i := arr.FIRST;
  LOOP
    EXIT WHEN i IS NULL;

    error_msg := val (rv => arr(i));

    -- raise the error on the first record with any error (stop validating
    -- subsequent records)
    IF error_msg IS NOT NULL THEN
      UTIL.raise_error(error_msg || ' (row ' || i || ')', scope, params);
    END IF;

    i := arr.NEXT(i);
  END LOOP;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END bulk_val;

FUNCTION ins (rv IN rvtype) RETURN rowtype IS
  scope     logger_logs.scope%type := scope_prefix || 'ins';
  params    logger.tab_param;
  lr        rvtype := rv;
  r         rowtype;
  error_msg VARCHAR2(32767);
BEGIN
  append_params(params, rv);
  logger.log('START', scope, null, params);

  error_msg := val (rv => rv);

  IF error_msg IS NOT NULL THEN
    UTIL.raise_error(error_msg, scope, params);
  END IF;
  
  lr := rv;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_INS>

  INSERT INTO <%table>
        (<%COLUMNS EXCLUDING GENERATED>
        #col#~
        ,<%END>)
  VALUES(<%COLUMNS EXCLUDING GENERATED>
         #seq#.NEXTVAL{SURROGATE_KEY}~
         lr.#col#~
         UTIL.num_val(lr.#col#){NUMBER}~
         UTIL.date_val(lr.#col#){DATE}~
         UTIL.datetime_val(lr.#col#){DATETIME}~
         UTIL.timestamp_val(lr.#col#){TIMESTAMP}~
         UTIL.timestamp_tz_val(lr.#col#){TIMESTAMP_TZ}~
        ,<%END>)
  RETURNING
         <%COLUMNS INCLUDING VIRTUAL,ROWID>
         #col#~
        ,<%END>
  INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
         r.#col#~
        ,<%END>;

  logger.log('INSERT <%table>: ' || SQL%ROWCOUNT, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_INS>

  append_params(params, r);
  logger.log('END', scope, null, params);
  RETURN r;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END ins;

FUNCTION bulk_ins (arr IN rvarraytype) RETURN NUMBER IS
  scope    logger_logs.scope%type := scope_prefix || 'bulk_ins';
  params   logger.tab_param;
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN
  logger.append_param(params, 'arr.COUNT', arr.COUNT);
  logger.log('START', scope, null, params);

  bulk_val(arr);

  lr := arr;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_BULK_INS>

  FORALL i IN INDICES OF arr
    INSERT INTO <%table>
           (<%COLUMNS EXCLUDING GENERATED>
            #col#~
           ,<%END>)
    VALUES (<%COLUMNS EXCLUDING GENERATED>
            #seq#.NEXTVAL{SURROGATE_KEY}~
            lr(i).#col#~
            UTIL.num_val(lr(i).#col#){NUMBER}~
            UTIL.date_val(lr(i).#col#){DATE}~
            UTIL.datetime_val(lr(i).#col#){DATETIME}~
            UTIL.timestamp_val(lr(i).#col#){TIMESTAMP}~
            UTIL.timestamp_tz_val(lr(i).#col#){TIMESTAMP_TZ}~
           ,<%END>);

  rowcount := SQL%ROWCOUNT;

  logger.log('INSERT <%table>: ' || rowcount, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_BULK_INS>

  logger.log('END', scope, 'rowcount=' || rowcount, params);
  RETURN rowcount;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END bulk_ins;

FUNCTION upd (rv IN rvtype) RETURN rowtype IS
  scope     logger_logs.scope%type := scope_prefix || 'upd';
  params    logger.tab_param;
  lr        rvtype := rv;
  r         rowtype;
  error_msg VARCHAR2(32767);
BEGIN
  append_params(params, rv);
  logger.log('START', scope, null, params);

  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
  assert(rv.#col# IS NOT NULL, '#col# cannot be null', scope);~
  <%END>

  error_msg := val (rv => rv);

  IF error_msg IS NOT NULL THEN
    UTIL.raise_error(error_msg, scope, params);
  END IF;

  lr := rv;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_UPD>

  UPDATE <%table> x
  SET    <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY>
         x.#col#... = lr.#col#~
         x.#col#... = UTIL.num_val(lr.#col#){NUMBER}~
         x.#col#... = UTIL.date_val(lr.#col#){DATE}~
         x.#col#... = UTIL.datetime_val(lr.#col#){DATETIME}~
         x.#col#... = UTIL.timestamp_val(lr.#col#){TIMESTAMP}~
         x.#col#... = UTIL.timestamp_tz_val(lr.#col#){TIMESTAMP_TZ}}~
        ,<%END>
  WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
         x.#col#... = lr.#col#~
  AND    <%END>
  RETURNING
         <%COLUMNS INCLUDING VIRTUAL,ROWID>
         #col#~
        ,<%END>
  INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
         r.#col#~
        ,<%END>;

  IF SQL%NOTFOUND THEN
    RAISE UTIL.lost_update;
  END IF;

  logger.log('UPDATE <%table>: ' || SQL%ROWCOUNT, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_UPD>

  append_params(params, r);
  logger.log('END', scope, null, params);
  RETURN r;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_ref_con_violation (scope, params);
  WHEN UTIL.lost_update THEN
    lost_upd (rv => rv);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END upd;

FUNCTION bulk_upd (arr IN rvarraytype) RETURN NUMBER IS
  scope    logger_logs.scope%type := scope_prefix || 'bulk_upd';
  params   logger.tab_param;
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN
  logger.append_param(params, 'arr.COUNT', arr.COUNT);
  logger.log('START', scope, null, params);

  bulk_val(arr);

  lr := arr;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_BULK_UPD>

  FORALL i IN INDICES OF arr
    UPDATE <%table> x
    SET    <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY>
           x.#col#... = lr(i).#col#~
           x.#col#... = UTIL.num_val(lr(i).#col#){NUMBER}~
           x.#col#... = UTIL.date_val(lr(i).#col#){DATE}~
           x.#col#... = UTIL.datetime_val(lr(i).#col#){DATETIME}~
           x.#col#... = UTIL.timestamp_val(lr(i).#col#){TIMESTAMP}~
           x.#col#... = UTIL.timestamp_tz_val(lr(i).#col#){TIMESTAMP_TZ}~
          ,<%END>
    WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
           x.#col#... = lr(i).#col#~
    AND    <%END>;

  rowcount := SQL%ROWCOUNT;

  logger.log('UPDATE <%table>: ' || rowcount, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_BULK_UPD>

  logger.log('END', scope, null, params);
  RETURN rowcount;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_ref_con_violation (scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END bulk_upd;

PROCEDURE del (rv IN rvtype) IS
  scope  logger_logs.scope%type := scope_prefix || 'del';
  params logger.tab_param;
  lr rvtype := rv;
BEGIN
  append_params(params, rv);
  logger.log('START', scope, null, params);

  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
  assert(rv.#col# IS NOT NULL, '#col# cannot be null', scope);~
  <%END>

  lr := rv;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_DEL>

  DELETE <%table> x
  WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
         x.#col#... = lr.#col#~
  AND    <%END>;

  IF SQL%NOTFOUND THEN
    RAISE UTIL.lost_update;
  END IF;

  logger.log('DELETE <%table>: ' || SQL%ROWCOUNT, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_DEL>

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_del_ref_con_violation (scope, params);
  WHEN UTIL.lost_update THEN
    lost_upd (rv => rv);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END del;

FUNCTION bulk_del (arr IN rvarraytype) RETURN NUMBER IS
  scope    logger_logs.scope%type := scope_prefix || 'bulk_del';
  params   logger.tab_param;
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN
  logger.append_param(params, 'arr.COUNT', arr.COUNT);
  logger.log('START', scope, null, params);

  lr := arr;

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_PRE_BULK_DEL>

  FORALL i IN INDICES OF arr
    DELETE <%table> x
    WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
           x.#col#... = lr(i).#col#~
    AND    <%END>;

  rowcount := SQL%ROWCOUNT;

  logger.log('DELETE <%table>: ' || rowcount, scope, null, params);

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_POST_BULK_DEL>

  logger.log('END', scope, 'rowcount=' || rowcount, params);
  RETURN rowcount;
EXCEPTION
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_del_ref_con_violation (scope, params);
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END bulk_del;

-- convert an rvtype to a rowtype, no validation (exceptions may be raised on
-- datatype conversion errors), no audit columns
FUNCTION to_rowtype (rv IN rvtype) RETURN rowtype IS
  scope  logger_logs.scope%type := scope_prefix || 'to_rowtype';
  params logger.tab_param;
  r      rowtype;
BEGIN
  append_params(params, rv);
  logger.log('START', scope, null, params);

  <%COLUMNS EXCLUDING AUDIT>
  r.#col#... := rv.#col#;~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.DATE_FORMAT);{DATE}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  r.#col#... := rv.#col#;{ROWID}~
  <%END>

  append_params(params, r);
  logger.log('END', scope, null, params);
  RETURN r;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END to_rowtype;

-- convert a rowtype to an rvtype
FUNCTION to_rvtype (r IN rowtype) RETURN rvtype IS
  scope  logger_logs.scope%type := scope_prefix || 'to_rvtype';
  params logger.tab_param;
  rv     rvtype;
BEGIN
  append_params(params, r);
  logger.log('START', scope, null, params);

  <%COLUMNS EXCLUDING AUDIT INCLUDING ROWID>
  rv.#col#... := r.#col#;~
  rv.#col#... := UTIL.date_val(r.#col#);{DATE}~
  rv.#col#... := UTIL.datetime_val(r.#col#);{DATETIME}~
  rv.#col#... := UTIL.timestamp_val(r.#col#);{TIMESTAMP}~
  rv.#col#... := UTIL.timestamp_tz_val(r.#col#);{TIMESTAMP_TZ}~
  rv.#col#... := r.#col#;{ROWID}~
  <%END>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_TO_RVTYPE>

  append_params(params, rv);
  logger.log('END', scope, null, params);
  RETURN rv;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END to_rvtype;

FUNCTION get (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
              #col#... IN <%table>.#col#%TYPE~
              p_#col# IN VARCHAR2{ROWID}~
              #col#... IN <%table>.#col#%TYPE := NULL{VERSION_ID}~
             ,<%END>
             ,as_at   IN TIMESTAMP := NULL) RETURN rowtype IS
  scope   logger_logs.scope%type := scope_prefix || 'get';
  params  logger.tab_param;
  r       rowtype;
BEGIN
  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
  logger.append_param(params, '#col#', #col#);~
  logger.append_param(params, 'p_#col#', p_#col#);{ROWID}~
  <%END>
  logger.append_param(params, 'as_at', as_at);
  logger.log('START', scope, null, params);

  IF <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>#col# IS NOT NULL~p_#col# IS NOT NULL{ROWID}~
  OR <%END> THEN
  
    IF as_at IS NOT NULL THEN

      SELECT <%COLUMNS INCLUDING VIRTUAL>
             x.#col#~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL>
             r.#col#~
            ,<%END>
      FROM   <%table> AS OF TIMESTAMP as_at x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.ROWID = get.p_rowid{ROWID}~
      AND    <%END>;

    ELSIF version_id IS NOT NULL THEN
    
      SELECT <%COLUMNS INCLUDING VIRTUAL>
             x.#col#~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL>
             r.#col#~
            ,<%END>
      FROM   <%journal> x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.ROWID = get.p_rowid{ROWID}~
      AND    <%END>;
    
    ELSE
  
      SELECT <%COLUMNS INCLUDING VIRTUAL,ROWID>
             x.#col#~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
             r.#col#~
            ,<%END>
      FROM   <%table> x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.ROWID = get.p_rowid{ROWID}~
      AND    <%END>;

    END IF;

  ELSE

    -- set up default record
    <%COLUMNS ONLY DEFAULT_VALUE EXCLUDING GENERATED,SURROGATE_KEY>
    r.#col#... := #DATA_DEFAULT#;~
    NULL;{NONE}~
    <%END>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_SET_DEFAULT>

  END IF;

  append_params(params, r);
  logger.log('END', scope, null, params);
  RETURN r;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    logger.log_error('No Data Found', scope, null, params);
    RAISE;
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END get;

FUNCTION copy (r IN rowtype) RETURN rowtype IS
  scope  logger_logs.scope%type := scope_prefix || 'copy';
  params logger.tab_param;
  nr     rowtype;
BEGIN
  append_params(params, r);
  logger.log('START', scope, null, params);
  
  nr := r;

  <%COLUMNS ONLY GENERATED,SURROGATE_KEY,IDENTITY,ROWID>
  nr.#col#... := NULL;~
  <%END>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_COPY>

  append_params(params, nr);
  logger.log('END', scope, null, params);
  RETURN nr;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END copy;

FUNCTION to_string
  (r   IN rowtype
  ,sep IN VARCHAR2 := '|'
  ) RETURN CLOB IS
  scope  logger_logs.scope%type := scope_prefix || 'to_string';
  params logger.tab_param;
  digest CLOB;
BEGIN
  append_params(params, r);
  logger.append_param(params, 'sep', sep);
  logger.log('START', scope, null, params);

<%IF DBMS_CRYPTO>
  <%COLUMNS EXCLUDING GENERATED>
  digest := digest || sep || r.#col#;~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATE_FORMAT);{DATE}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  digest := digest || sep || DBMS_CRYPTO.hash(src => r.#col#, typ => DBMS_CRYPTO.HASH_MD5);{BLOB}~
  digest := digest || sep || DBMS_CRYPTO.hash(src => UTL_RAW.cast_to_raw(r.#col#), typ => DBMS_CRYPTO.HASH_MD5);{CLOB}~
  <%END>
<%ELSE>
  <%COLUMNS EXCLUDING GENERATED,LOBS>
  digest := digest || sep || r.#col#;~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATE_FORMAT);{DATE}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  <%END>
<%END IF>

  logger.log('END', scope, 'digest=' || digest, params);
  RETURN digest;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END to_string;
<%IF DBMS_CRYPTO>
FUNCTION hash (r IN rowtype) RETURN VARCHAR2 IS
  scope  logger_logs.scope%type := scope_prefix || 'hash';
  params logger.tab_param;
  digest CLOB;
  ret    RAW(2000);
BEGIN
  append_params(params, r);
  logger.log('START', scope, null, params);

  digest := to_string(r => r, sep => '|');

  ret := DBMS_CRYPTO.hash(digest, DBMS_CRYPTO.hash_sh1);

  logger.log('END', scope, 'hash=' || ret, params);
  RETURN ret;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END hash;
<%END IF>

<%INCLUDE <%TEMPLATE>.TAPI_PACKAGE_BODY_METHODS>

-- may be used to disable and re-enable the journal trigger for this session
PROCEDURE disable_journal_trigger IS
  scope  logger_logs.scope%type := scope_prefix || 'disable_journal_trigger';
  params logger.tab_param;
BEGIN
  logger.log('START', scope, null, params);
<%IF SECURITY_CONTEXT>
  SECURITY.disable_journal_trigger('<%TRIGGER>');
<%ELSE>
  g_trigger_disabled := TRUE;
<%END IF>
  logger.log('END', scope, null, params);
EXCEPTION
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END disable_journal_trigger;

PROCEDURE enable_journal_trigger IS
  scope  logger_logs.scope%type := scope_prefix || 'enable_journal_trigger';
  params logger.tab_param;
BEGIN
  logger.log('START', scope, null, params);
<%IF SECURITY_CONTEXT>
  SECURITY.enable_journal_trigger('<%TRIGGER>');
<%ELSE>
  g_trigger_disabled := FALSE;
<%END IF>
  logger.log('END', scope, null, params);
EXCEPTION
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END enable_journal_trigger;

FUNCTION journal_trigger_enabled RETURN BOOLEAN IS
  scope  logger_logs.scope%type := scope_prefix || 'journal_trigger_enabled';
  params logger.tab_param;
  ret    BOOLEAN;
BEGIN
  logger.log('START', scope, null, params);
<%IF SECURITY_CONTEXT>
  ret := SYS_CONTEXT('<%CONTEXT>','<%TRIGGER>') IS NULL;
<%ELSE>
  ret := NOT NVL(g_trigger_disabled, FALSE);
<%END IF>
  logger.log('END', scope, 'enabled=' || logger.tochar(ret), params);
  RETURN ret;
EXCEPTION
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END journal_trigger_enabled;

END <%TAPI>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE APEXAPI_PACKAGE_SPEC>
CREATE OR REPLACE PACKAGE <%APEXAPI> AS
/*******************************************************************************
 Apex API for <%TABLE>
 <%SYSDATE> - Generated by <%USER>
 Note: custom code for this table may be compiled in package <%TEMPLATE>. 
*******************************************************************************/

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_SPEC_DEC>

-- page load process
PROCEDURE load;

-- single-record page validation
PROCEDURE val;

-- validate the record but don't record failures as errors; instead, return a
-- list of the errors as "warnings" only
FUNCTION errors_as_warnings RETURN VARCHAR2;

-- multi-record page validation
PROCEDURE val_row
  (rv               IN <%TAPI>.rvtype
  ,region_static_id IN VARCHAR2);

-- page submit process
PROCEDURE process;

-- tabular form process row
PROCEDURE apply_mr (rv IN <%TAPI>.rvtype);

-- Interactive Grid process row
PROCEDURE apply_ig (rv IN <%TAPI>.rvtype);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_SPEC_METHODS>

END <%APEXAPI>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE APEXAPI_PACKAGE_BODY>
CREATE OR REPLACE PACKAGE BODY <%APEXAPI> AS
/*******************************************************************************
 Table API for <%TABLE>
 <%SYSDATE> - Generated by <%USER>
 Note: custom code for this table may be compiled in package <%TEMPLATE>. 
*******************************************************************************/

scope_prefix constant varchar2(31) := lower($$plsql_unit) || '.';

-- column name constants
<%COLUMNS INCLUDING ROWID>
C_#COL28#... CONSTANT VARCHAR2(30) := '#COL#';~
<%END>

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_BODY_DEC>

-- Note: if the record is identified by ROWID it's the caller's responsibility
-- to maintain the Pn_ROWID item value.
PROCEDURE apex_set (r IN <%TAPI>.rowtype) IS
  scope  logger_logs.scope%type := scope_prefix || 'apex_set';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
BEGIN
  <%TAPI>.append_params(params, r);
  logger.log('START', scope, null, params);

  <%COLUMNS INCLUDING VIRTUAL,ROWID EXCLUDING LOBS>
  sv(p||C_#COL28#,... r.#col#);~
  sd(p||C_#COL28#,... r.#col#);{DATE}~
  sd(p||C_#COL28#,... r.#col#);{DATETIME}~
  st(p||C_#COL28#,... r.#col#);{TIMESTAMP}~
  st(p||C_#COL28#,... r.#col#);{TIMESTAMP_TZ}~
  <%END>
  
<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_APEX_SET>

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END apex_set;

FUNCTION apex_get_pk RETURN <%TAPI>.rvtype IS
  scope  logger_logs.scope%type := scope_prefix || 'apex_get_pk';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     <%TAPI>.rvtype;
BEGIN
  logger.log('START', scope, null, params);

  IF APEX_APPLICATION.g_request = 'COPY' THEN

    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    rv.#col#... := v(p||'COPY_'||C_#COL28#);~
    rv.#col#... := nv(p||'COPY_'||C_#COL28#);{ID}~
    <%END>

    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    assert(rv.#col# IS NOT NULL, p||'COPY_'||C_#COL28#||' cannot be null', scope);~
    <%END>

  ELSE

    <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
    rv.#col#... := v(p||C_#COL28#);~
    rv.#col#... := nv(p||C_#COL28#);{ID}~
    <%END>

  END IF;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_APEX_GET_PK>

  <%TAPI>.append_params(params, rv);
  logger.log('END', scope, null, params);
  RETURN rv;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END apex_get_pk;

FUNCTION apex_get RETURN <%TAPI>.rvtype IS
  scope  logger_logs.scope%type := scope_prefix || 'apex_get';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  r      <%TAPI>.rowtype;
  rv     <%TAPI>.rvtype;
BEGIN
  logger.log('START', scope, null, params);

  rv := apex_get_pk;
  
  r := <%TAPI>.get
         (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
          #col# => rv.#col#~
          p_#col# => rv.#col#{ROWID}~
         ,<%END>);
  
  rv := <%TAPI>.to_rvtype(r => r);

  <%COLUMNS EXCLUDING AUDIT,LOBS INCLUDING ROWID>
  rv.#col#... := v(p||C_#COL28#);~
  rv.#col#... := nv(p||C_#COL28#);{ID}~
  <%END>

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_APEX_GET>
  
  <%TAPI>.append_params(params, rv);
  logger.log('END', scope, null, params);
  RETURN rv;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END apex_get;

/*******************************************************************************
                               PUBLIC INTERFACE
*******************************************************************************/

PROCEDURE load IS
  scope  logger_logs.scope%type := scope_prefix || 'load';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     <%TAPI>.rvtype;
  r      <%TAPI>.rowtype;
BEGIN
  UTIL.append_apex_params(params);
  logger.log('START', scope, null, params);
  logger.log_apex_items (p_log_null_items => FALSE);

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Reporting<%END IF>);

  rv := apex_get_pk;
  r := <%TAPI>.get
         (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
          #col# => rv.#col#~
          p_#col# => rv.#col#{ROWID}~
         ,<%END>);

  IF APEX_APPLICATION.g_request = 'COPY' THEN

    r := <%TAPI>.copy(r);
    <%IF ROWID>UTIL.sv(p||C_ROWID,'');<%END IF>

  END IF;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_LOAD>

  apex_set (r => r);

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END load;

PROCEDURE val IS
  scope         logger_logs.scope%type := scope_prefix || 'val';
  params        logger.tab_param;
  p             VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv            <%TAPI>.rvtype;
  dummy         VARCHAR2(32767);
  item_name_map UTIL.str_map;
BEGIN
  UTIL.append_apex_params(params);
  logger.log('START', scope, null, params);
  logger.log_apex_items (p_log_null_items => FALSE);

  IF APEX_APPLICATION.g_request = 'CREATE'
  OR APEX_APPLICATION.g_request LIKE 'SAVE%' THEN

    rv := apex_get;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_ITEMMAP>

    UTIL.pre_val
      (label_map     => <%TAPI>.label_map
      ,item_name_map => item_name_map);

    dummy := <%TAPI>.val (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_VAL>

    UTIL.post_val;

  END IF;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END val;

FUNCTION errors_as_warnings RETURN VARCHAR2 IS
  scope  logger_logs.scope%type := scope_prefix || 'errors_as_warnings';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     <%TAPI>.rvtype;
  arr    UTIL.msg_array;
  buf    VARCHAR2(32767);
BEGIN
  logger.log('START', scope, null, params);

  rv := apex_get;

  IF <%TAPI>.val (rv => rv) IS NOT NULL THEN
    buf := UTIL.errors_list;
  END IF;

  logger.append_param(params, 'buf', buf);
  logger.log('END', scope, null, params);
  RETURN buf;
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END errors_as_warnings;

PROCEDURE val_row
  (rv               IN <%TAPI>.rvtype
  ,region_static_id IN VARCHAR2
  ) IS
  scope            logger_logs.scope%type := scope_prefix || 'val_row';
  params           logger.tab_param;
  dummy            VARCHAR2(32767);
  column_alias_map UTIL.str_map;
BEGIN
  UTIL.append_apex_params(params);
  logger.append_param(params, 'APEX$ROW_NUM', nv('APEX$ROW_NUM'));
  logger.append_param(params, 'APEX$ROW_SELECTOR', v('APEX$ROW_SELECTOR'));
  logger.append_param(params, 'APEX$ROW_STATUS', v('APEX$ROW_STATUS'));
  <%TAPI>.append_params(params, rv);
  logger.log('START', scope, null, params);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_COLUMNMAP>

  UTIL.pre_val_row
    (label_map        => <%TAPI>.label_map
    ,region_static_id => region_static_id
    ,column_alias_map => column_alias_map);

  dummy := <%TAPI>.val (rv => rv);

  UTIL.post_val;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END val_row;

PROCEDURE process IS
  scope  logger_logs.scope%type := scope_prefix || 'process';
  params logger.tab_param;
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     <%TAPI>.rvtype;
  r      <%TAPI>.rowtype;
BEGIN
  UTIL.append_apex_params(params);
  logger.log('START', scope, null, params);
  logger.log_apex_items (p_log_null_items => FALSE);

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  CASE
  WHEN APEX_APPLICATION.g_request = 'CREATE' THEN

    rv := apex_get;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_INS>

    r := <%TAPI>.ins (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_INS>

    apex_set (r => r);

    UTIL.success('<%Entity> created.');

  WHEN APEX_APPLICATION.g_request LIKE 'SAVE%' THEN

    rv := apex_get;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_UPD>

    r := <%TAPI>.upd (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_UPD>

    apex_set (r => r);
    UTIL.success('<%Entity> updated.'
      || CASE WHEN APEX_APPLICATION.g_request = 'SAVE_COPY' THEN ' Ready to create new <%entity>.' END);

  WHEN APEX_APPLICATION.g_request = 'DELETE' THEN

    rv := apex_get_pk;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_DEL>

    <%TAPI>.del (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_DEL>

    UTIL.clear_page_cache;

    UTIL.success('<%Entity> deleted.');

  ELSE
    NULL;
  END CASE;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END process;

PROCEDURE apply_mr (rv IN <%TAPI>.rvtype) IS
  scope  logger_logs.scope%type := scope_prefix || 'apply_mr';
  params logger.tab_param;
  r      <%TAPI>.rowtype;
BEGIN
  UTIL.append_apex_params(params);
  logger.append_param(params, 'APEX$ROW_NUM', nv('APEX$ROW_NUM'));
  logger.append_param(params, 'APEX$ROW_SELECTOR', v('APEX$ROW_SELECTOR'));
  logger.append_param(params, 'APEX$ROW_STATUS', v('APEX$ROW_STATUS'));
  <%TAPI>.append_params(params, rv);
  logger.log('START', scope, null, params);

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  IF APEX_APPLICATION.g_request = 'MULTI_ROW_DELETE' THEN

    IF v('APEX$ROW_SELECTOR') = 'X' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_DEL_MR>

      <%TAPI>.del (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_DEL_MR>

    END IF;

  ELSE

    CASE v('APEX$ROW_STATUS')
    WHEN 'C' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_INS_MR>

      r := <%TAPI>.ins (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_INS_MR>

    WHEN 'U' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_UPD_MR>

      r := <%TAPI>.upd (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_UPD_MR>

    ELSE
      NULL;
    END CASE;

  END IF;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END apply_mr;

PROCEDURE apply_ig (rv IN <%TAPI>.rvtype) IS
  scope  logger_logs.scope%type := scope_prefix || 'apply_ig';
  params logger.tab_param;
  r      <%TAPI>.rowtype;
BEGIN
  UTIL.append_apex_params(params);
  logger.append_param(params, 'APEX$ROW_STATUS', v('APEX$ROW_STATUS'));
  <%TAPI>.append_params(params, rv);
  logger.log('START', scope, null, params);

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  CASE v('APEX$ROW_STATUS')
  WHEN 'I' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_INS_MR>

    r := <%TAPI>.ins (rv => rv);
    
    -- Interactive Grid needs the new PK in order to find the new record
    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    sv('#COL#',... r.#col#);~
    <%END>

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_INS_MR>

  WHEN 'U' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_UPD_MR>

    r := <%TAPI>.upd (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_UPD_MR>

  WHEN 'D' THEN

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_PRE_DEL_MR>

    <%TAPI>.del (rv => rv);

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_POST_DEL_MR>

  END CASE;

  logger.log('END', scope, null, params);
EXCEPTION
  WHEN UTIL.application_error THEN
    logger.log_error('Application Error', scope, null, params);
    RAISE;
  WHEN OTHERS THEN
    logger.log_error('Unhandled Exception', scope, null, params);
    RAISE;
END apply_ig;

<%INCLUDE <%TEMPLATE>.APEXAPI_PACKAGE_BODY_METHODS>

END <%APEXAPI>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE CREATE_LOV_VIEW>
create or replace view <%view> as
select <%COLUMNS EXCLUDING GENERATED>
       #col#~
      ,<%END>
      <%COLUMNS ONLY START_DATE>
      ,case
       when end_date < trunc(sysdate) then 'EXPIRED'
       when start_date >= trunc(sysdate) then 'FUTURE'
       end as inactive_code
       <%END>
      ,<%COLUMNS EXCLUDING PK,GENERATED,SORT_ORDER,START_DATE,END_DATE,ID,IND,CODE>
       #col#~
       || ' ' || <%END>
       <%COLUMNS ONLY VISIBLE_IND,START_DATE,ENABLED_IND>
       ~
       || case when visible_ind is null then '*' end{VISIBLE_IND}~
       || case when enabled_ind is null then ' (DISABLED)' end{ENABLED_IND}~
       || case when end_date < trunc(sysdate) then ' (EXPIRED)'
               when start_date >= trunc(sysdate) then ' (FUTURE)'
          end{START_DATE}~
       <%END> as lov_name
      ,row_number() over
         (order by <%COLUMNS ONLY START_DATE>
            case
            when end_date < trunc(sysdate) then 2
            when start_date >= trunc(sysdate) then 1
            else 0
            end
           ,<%END><%COLUMNS ONLY ENABLED_IND>
            enabled_ind nulls first
           ,<%END>sort_order
           ,<%COLUMNS EXCLUDING PK,GENERATED,SORT_ORDER,START_DATE,END_DATE,ID,IND,CODE>
            #col#~
           ,<%END>) as lov_sort_order
from <%table>;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_INSERT>
SELECT 'insert into <%table>(<%COLUMNS <%columnspec>>#col#~,<%END>)values(<%COLUMNS <%columnspec>>
'''||REPLACE(REPLACE(#col#,'''',''''''),CHR(38),'''||CHR(38)||''')||'''~
'||NVL(TO_CHAR(#col#),'null')||'{NUMBER}~
'||NVL(TO_CHAR(#col#),'null')||'{ID}~
'||CASE WHEN #col# IS NOT NULL THEN 'date'''||TO_CHAR(#col#,'YYYY-MM-DD')||'''' ELSE 'null' END||'{DATE}~
'||CASE WHEN #col# IS NOT NULL THEN 'to_date('''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS')||''',''YYYY-MM-DD HH24:MI:SS'')' ELSE 'null' END||'{DATETIME}~
'||CASE WHEN #col# IS NOT NULL THEN 'timestamp'''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF')||'''' ELSE 'null' END||'{TIMESTAMP}~
'||CASE WHEN #col# IS NOT NULL THEN 'timestamp'''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM')||'''' ELSE 'null' END||'{TIMESTAMP_TZ}~
,<%END>
);' q FROM <%table> t ORDER BY 1
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_CSV_HEADER>

<%COLUMNS <%columnspec>>#HEADER#~,<%END>

<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_CSV>
SELECT <%COLUMNS <%columnspec>>
CASE WHEN INSTR(#col#,',')>0 OR INSTR(#col#,'"')>0 OR INSTR(#col#,CHR(10))>0 THEN '"'||REPLACE(#col#,'"','""')||'"' ELSE #col# END~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){NUMBER}~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){BINARY_FLOAT}~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){BINARY_DOUBLE}~
TO_CHAR(#col#,'fm999990'){ID}~
TO_CHAR(#col#,'YYYY-MM-DD'){DATE}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS'){DATETIME}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF'){TIMESTAMP}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM'){TIMESTAMP_TZ}~
||','||<%END> FROM <%table> t ORDER BY 1
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE CODESAMPLES>

-- The following are code samples to copy-and-paste into Apex as needed.

-- Put this in the Tabular Form validation "PL/SQL Function (returning Error
-- Text)" For Each Row:
<%APEXAPI>.val_row (rv =>
  <%TAPI>.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID>
     #col#... => :#COL#~
     #col#... => :P_#COL#{ROWID}~
    ,<%END>
    )
  ,region_static_id => '<%table>');

-- Put this in a Tabular Form process:
<%APEXAPI>.apply_mr (rv =>
  <%TAPI>.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID>
     #col#... => :#COL#~
     #col#... => :P_#COL#{ROWID}~
    ,<%END>
    ));

-- Put this in an Interactive Grid validation "PL/SQL Function (returning Error
-- Text)" For Created and Modified Rows
RETURN <%TAPI>.val (rv =>
  <%TAPI>.rv
    (<%COLUMNS EXCLUDING AUDIT>
     #col#... => :#COL#~
    ,<%END>
    ));

-- Put this in an "Interactive Grid - Automatic Row Processing (DML)" process
-- with Target Type = PL/SQL Code
<%APEXAPI>.apply_ig (rv =>
  <%TAPI>.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID>
     #col#... => :#COL#~
    ,<%END>
    ));

<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

$end
END TEMPLATES;
/