create or replace PACKAGE TEMPLATES AS
/*******************************************************************************
 Code templates used by GENERATE - uninstrumented
 09-FEB-2016 Jeffrey Kemp
 Each template starts with <%TEMPLATE [name]> and ends with <%END TEMPLATE>
 For syntax, refer to:
 https://bitbucket.org/jk64/jk64-sample-apex-tapi/wiki/Template%20Syntax
 Note: no package body is required.
*******************************************************************************/

-- tables to be processed by the "generate all" procedures
ALL_TABLES_LIST CONSTANT t_str_array := t_str_array
  ('EMPS', 'EVENT_TYPES', 'EVENTS', 'HOSTS', 'VENUES');

JOURNAL_TAB_SUFFIX  CONSTANT VARCHAR2(30) := '$JN';
JOURNAL_TRG_SUFFIX  CONSTANT VARCHAR2(30) := '$TRG';
TAPI_SUFFIX         CONSTANT VARCHAR2(30) := '$TAPI';
APEXAPI_SUFFIX      CONSTANT VARCHAR2(30) := '$APEX';
TEMPLATE_SUFFIX     CONSTANT VARCHAR2(30) := '$GEN';

-- column lists
AUDIT_COLUMNS_LIST     CONSTANT VARCHAR2(100) := 'CREATED_DT,CREATED_BY,LAST_UPDATED_DT,LAST_UPDATED_BY';
GENERATED_COLUMNS_LIST CONSTANT VARCHAR2(100) := AUDIT_COLUMNS_LIST||',VERSION_ID';

LOB_DATATYPES_LIST     CONSTANT VARCHAR2(100) := 'BLOB,BFILE,CLOB,NCLOB,XMLTYPE';

--avoid compilation of the template code
$if false $then
--(these borders are just to visually separate the templates, they're not significant)
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

-- This journal trigger performs reasonably well for bulk inserts/updates/
-- deletes by keeping the changed records in a small array and flushing only
-- after 100 records. The number 100 is a compromise between not allowing too
-- many concurrent sessions from using lots of memory, while not doing too many
-- small-array inserts into the journal table.
-- In the degenerate case (where the application is doing single-row DML) it
-- adds only minimal overhead.
<%TEMPLATE CREATE_JOURNAL_TRIGGER>
CREATE OR REPLACE TRIGGER #TRIGGER#
  FOR INSERT OR UPDATE OR DELETE ON #TABLE#
  <%IF SECURITY_CONTEXT>WHEN (SYS_CONTEXT('#CONTEXT#','#TRIGGER#') IS NULL)<%END IF>
  COMPOUND TRIGGER
/*******************************************************************************
 Journal Trigger - DO NOT EDIT
 #SYSDATE# - Generated by #USER#
*******************************************************************************/

  FLUSH_THRESHOLD CONSTANT SIMPLE_INTEGER := 100;
  TYPE jnl_t IS TABLE OF #JOURNAL#%ROWTYPE
    INDEX BY SIMPLE_INTEGER;
  jnls jnl_t;

  PROCEDURE flush_array (arr IN OUT jnl_t) IS
  BEGIN
    FORALL i IN 1..arr.COUNT
      INSERT INTO #JOURNAL# VALUES arr(i);
    arr.DELETE;
  END flush_array;

  BEFORE EACH ROW IS
  BEGIN
    <%IF SECURITY_CONTEXT><%ELSE>IF #TAPI#.journal_trigger_enabled THEN<%END IF>
      IF UPDATING THEN
        :NEW.last_updated_by := NVL(#CONTEXT_APP_USER#,USER);
        :NEW.last_updated_dt := SYSDATE;
        :NEW.version_id      := :OLD.version_id + 1;
      END IF;
    <%IF SECURITY_CONTEXT><%ELSE>END IF;<%END IF>
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
    r #JOURNAL#%ROWTYPE;
  BEGIN
    <%IF SECURITY_CONTEXT><%ELSE>IF #TAPI#.journal_trigger_enabled THEN<%END IF>
      IF INSERTING OR UPDATING THEN
        <%COLUMNS INCLUDING VIRTUAL>
        r.#col#... := :NEW.#col#;~
        <%END>
        IF INSERTING THEN
          r.jn$action := 'I';
        ELSIF UPDATING THEN
          r.jn$action := 'U';
        END IF;
      ELSIF DELETING THEN
        <%COLUMNS INCLUDING VIRTUAL>
        r.#col#... := :OLD.#col#;~
        <%END>
        r.jn$action := 'D';
      END IF;
      r.jn$timestamp := SYSTIMESTAMP;
      r.jn$action_by := NVL(#CONTEXT_APP_USER#,USER);
      jnls(NVL(jnls.LAST,0) + 1) := r;
      IF jnls.COUNT >= FLUSH_THRESHOLD THEN
        flush_array(arr => jnls);
      END IF;
    <%IF SECURITY_CONTEXT><%ELSE>END IF;<%END IF>
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    flush_array(arr => jnls);
  END AFTER STATEMENT;

END #TRIGGER#;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE TAPI_PACKAGE_SPEC>
CREATE OR REPLACE PACKAGE #TAPI# AS
/*******************************************************************************
 Table API for #table#
 #SYSDATE# - Generated by #USER#
*******************************************************************************/

/********************** TODO: DELETE THIS MESSAGE ******************************
 This is just a generated starting point for this API. It needs to be customised
 for the specific requirements of the application.
*******************************************************************************/

/******************************* USAGE NOTES ***********************************
 Only call the single-row methods when only one row needs to be processed.
 Always call the bulk methods when more than one row needs to be processed.

 If a method is not perfectly suited to the task at hand (e.g. you want to
 update just two columns but all we have is a "update everything!" method),
 add a new one.

 Don't call a "get" function if you need to then correlate the results
 from other "get" functions - instead, put all the logic into a view.
*******************************************************************************/

CURSOR cur IS
  SELECT x.*
        ,x.ROWID AS "ROWID"
  FROM   #table# x;
SUBTYPE rowtype IS cur%ROWTYPE;
TYPE arraytype IS TABLE OF rowtype INDEX BY BINARY_INTEGER;

TYPE rvtype IS RECORD
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... VARCHAR2(4000)~
   #col#... #table#.#col#%TYPE{ID}~
   #col#... #table#.#col#%TYPE{BLOB}~
   #col#... #table#.#col#%TYPE{CLOB}~
   #col#... #table#.#col#%TYPE{XMLTYPE}~
   #col#... VARCHAR2(20){ROWID}~
   #col#... VARCHAR2(1){EVENTS.REPEAT_IND}~
  ,<%END>
  );
TYPE rvarraytype IS TABLE OF rvtype INDEX BY BINARY_INTEGER;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_SPEC_DEC>

-- return a rowtype with the given values
FUNCTION rec
  (<%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
   #col#... IN #table#.#col#%TYPE... := NULL~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rowtype;

-- return an rvtype with the given values
FUNCTION rv
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... IN VARCHAR2 := NULL~
   #col#... IN #table#.#col#%TYPE... := NULL{ID}~
   #col#... IN #table#.#col#%TYPE... := NULL{LOB}~
   #col#... IN VARCHAR2 := NULL{EVENTS.REPEAT_IND}~
  ,<%END>
  ) RETURN rvtype;

-- return a mapping of column name -> user-friendly label
FUNCTION label_map RETURN UTIL.str_map;

-- validate the row (returns an error message if invalid)
FUNCTION val (rv IN rvtype) RETURN VARCHAR2;

-- insert a row
FUNCTION ins (rv IN rvtype) RETURN rowtype;

-- insert multiple rows, array may be sparse; returns no. records inserted
FUNCTION bulk_ins (arr IN rvarraytype) RETURN NUMBER;

-- update a row
FUNCTION upd (rv IN rvtype) RETURN rowtype;

-- update multiple rows, array may be sparse; returns no. records updated
FUNCTION bulk_upd (arr IN rvarraytype) RETURN NUMBER;

-- delete a row
PROCEDURE del (rv IN rvtype);

-- delete multiple rows; array may be sparse; returns no. records deleted
FUNCTION bulk_del (arr IN rvarraytype) RETURN NUMBER;

-- convert an rvtype to a rowtype
FUNCTION to_rowtype (rv IN rvtype) RETURN rowtype;

-- convert a rowtype to an rvtype
FUNCTION to_rvtype (r IN rowtype) RETURN rvtype;

-- get a row (raise NO_DATA_FOUND if not found)
FUNCTION get (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
              #col#... IN #table#.#col#%TYPE~
              #col#... IN VARCHAR2{ROWID}~
              #col#... IN #table#.#col#%TYPE := NULL{VERSION_ID}~
             ,<%END>
             ,as_at   IN TIMESTAMP := NULL) RETURN rowtype;

-- convert to a copy
FUNCTION copy (r IN rowtype) RETURN rowtype;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_SPEC_METHODS>

-- concatenate to a single string
FUNCTION to_string
  (r   IN rowtype
  ,sep IN VARCHAR2 := '|'
  ) RETURN CLOB;

<%IF DBMS_CRYPTO>
-- generate a hash for the record
FUNCTION hash (r IN rowtype) RETURN VARCHAR2;
<%END IF>

-- Use these procedures to disable and re-enable the journal trigger just for
-- this session (to disable for all sessions, just disable the database trigger
-- instead).
PROCEDURE disable_journal_trigger;
PROCEDURE enable_journal_trigger;
FUNCTION journal_trigger_enabled RETURN BOOLEAN;

END #TAPI#;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE TAPI_PACKAGE_BODY>
CREATE OR REPLACE PACKAGE BODY #TAPI# AS
/*******************************************************************************
 Table API for #table#
 #SYSDATE# - Generated by #USER#
*******************************************************************************/

/********************** TODO: DELETE THIS MESSAGE ******************************
 This is just a generated starting point for this API. It needs to be customised
 for the specific requirements of the application.
*******************************************************************************/

scope_prefix constant varchar2(31) := lower($$plsql_unit) || '.';

-- column name constants
<%COLUMNS EXCLUDING GENERATED INCLUDING EVENTS.REPEAT_IND>
#COL#... CONSTANT VARCHAR2(30) := '#COL#';~
<%END>

<%IF SECURITY_CONTEXT><%ELSE>g_trigger_disabled BOOLEAN;<%END IF>

PROCEDURE lost_upd (rv IN rvtype) IS
  db_last_updated_by #table#.last_updated_by%TYPE;
  db_last_updated_dt #table#.last_updated_dt%TYPE;
BEGIN

  SELECT x.last_updated_by
        ,x.last_updated_dt
  INTO   db_last_updated_by
        ,db_last_updated_dt
  FROM   #table# x
  WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
         x.#col#... = rv.#col#~
         x.#COL#... = rv.#col#{ROWID}~
  AND    <%END>;

  UTIL.raise_lost_update
    (updated_by => db_last_updated_by
    ,updated_dt => db_last_updated_dt);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    UTIL.raise_error('LOST_UPDATE_DEL');
END lost_upd;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_DEC>

/*******************************************************************************
                               PUBLIC INTERFACE
*******************************************************************************/

FUNCTION rec
  (<%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
   #col#... IN #table#.#col#%TYPE... := NULL~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rowtype IS
  r      rowtype;
BEGIN
  
  <%COLUMNS INCLUDING ROWID EXCLUDING GENERATED>
  r.#col#... := #col#;~
  <%END>

  RETURN r;
END rec;

-- return an rvtype with the given values
FUNCTION rv
  (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
   #col#... IN VARCHAR2 := NULL~
   #col#... IN #table#.#col#%TYPE... := NULL{ID}~
   #col#... IN #table#.#col#%TYPE... := NULL{LOB}~
   #col#... IN VARCHAR2 := NULL{EVENTS.REPEAT_IND}~
   #col#... IN VARCHAR2 := NULL{ROWID}~
  ,<%END>
  ) RETURN rvtype IS
  rv     rvtype;
BEGIN

  <%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
  rv.#col#... := #col#;~
  <%END>

  RETURN rv;
END rv;

FUNCTION label_map RETURN UTIL.str_map IS
  lm      UTIL.str_map;
BEGIN

  <%COLUMNS EXCLUDING GENERATED INCLUDING EVENTS.REPEAT_IND>
  lm(#COL#)... := '#Label#';~
  lm(#COL#)... := 'Calendar Style';{EVENT_TYPES.CALENDAR_CSS}~
  lm(#COL#)... := 'Repeat';{EVENTS.REPEAT_IND}~
  <%END>

  RETURN lm;
END label_map;

FUNCTION val (rv IN rvtype) RETURN VARCHAR2 IS
  -- Validates the record but without reference to any other rows or tables
  -- (i.e. avoid any queries in here).
  -- Unique and referential integrity should be validated via suitable db
  -- constraints (violations will be raised when the ins/upd/del is attempted).
  -- Complex cross-record validations should usually be performed by a XAPI
  -- prior to the call to the TAPI.
BEGIN

  <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY,NULLABLE,LOBS>
  UTIL.val_not_null (val => rv.#col#, column_name => #COL#);~
  <%END>
  <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY,LOBS INCLUDING EVENTS.REPEAT_IND>
  UTIL.val_ind (val => rv.#col#, column_name => #COL#);{IND}~
  UTIL.val_yn (val => rv.#col#, column_name => #COL#);{YN}~
  UTIL.val_max_len (val => rv.#col#, len => #MAXLEN#, column_name => #COL#);{VARCHAR2}~
  UTIL.val_numeric (val => rv.#col#, column_name => #COL#);{NUMBER}~
  UTIL.val_date (val => rv.#col#, column_name => #COL#);{DATE}~
  UTIL.val_datetime (val => rv.#col#, column_name => #COL#);{DATETIME}~
  UTIL.val_timestamp (val => rv.#col#, column_name => #COL#);{TIMESTAMP}~
  UTIL.val_timestamp_tz (val => rv.#col#, column_name => #COL#);{TIMESTAMP_TZ}~
  UTIL.val_integer (val => rv.#col#, range_low => 1, column_name => #COL#);{EVENTS.REPEAT_INTERVAL}~
  UTIL.val_domain
    (val          => rv.#col#
    ,valid_values => t_str_array(DAILY, WEEKLY, MONTHLY, ANNUALLY)
    ,column_name  => #COL#);{EVENTS.REPEAT}~
  ~
  <%END>
  
<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_VAL>

  RETURN UTIL.first_error;
END val;

PROCEDURE bulk_val (arr IN rvarraytype) IS
  i         BINARY_INTEGER;
  error_msg VARCHAR2(32767);
BEGIN

  i := arr.FIRST;
  LOOP
    EXIT WHEN i IS NULL;

    error_msg := val (rv => arr(i));

    -- raise the error on the first record with any error (stop validating
    -- subsequent records)
    IF error_msg IS NOT NULL THEN
      UTIL.raise_error(error_msg || ' (row ' || i || ')');
    END IF;

    i := arr.NEXT(i);
  END LOOP;

EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
END bulk_val;

FUNCTION ins (rv IN rvtype) RETURN rowtype IS
  lr        rvtype := rv;
  r         rowtype;
  error_msg VARCHAR2(32767);
BEGIN

  error_msg := val (rv => rv);

  IF error_msg IS NOT NULL THEN
    UTIL.raise_error(error_msg);
  END IF;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_INS>

  INSERT INTO #table#
        (<%COLUMNS EXCLUDING GENERATED>
        #col#~
        ,<%END>)
  VALUES(<%COLUMNS EXCLUDING GENERATED>
         #seq#.NEXTVAL{SURROGATE_KEY}~
         lr.#col#~
         UTIL.num_val(lr.#col#){NUMBER}~
         UTIL.date_val(lr.#col#){DATE}~
         UTIL.datetime_val(lr.#col#){DATETIME}~
         UTIL.timestamp_val(lr.#col#){TIMESTAMP}~
         UTIL.timestamp_tz_val(lr.#col#){TIMESTAMP_TZ}~
        ,<%END>)
  RETURNING
         <%COLUMNS INCLUDING VIRTUAL,ROWID>
         #col#~
         #COL#{ROWID}~
        ,<%END>
  INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
         r.#col#~
        ,<%END>;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_INS>

  RETURN r;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
END ins;

FUNCTION bulk_ins (arr IN rvarraytype) RETURN NUMBER IS
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN

  bulk_val(arr);

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_BULK_INS>

  FORALL i IN INDICES OF arr
    INSERT INTO #table#
           (<%COLUMNS EXCLUDING GENERATED>
            #col#~
           ,<%END>)
    VALUES (<%COLUMNS EXCLUDING GENERATED>
            #seq#.NEXTVAL{SURROGATE_KEY}~
            lr(i).#col#~
            UTIL.num_val(lr(i).#col#){NUMBER}~
            UTIL.date_val(lr(i).#col#){DATE}~
            UTIL.datetime_val(lr(i).#col#){DATETIME}~
            UTIL.timestamp_val(lr(i).#col#){TIMESTAMP}~
            UTIL.timestamp_tz_val(lr(i).#col#){TIMESTAMP_TZ}~
           ,<%END>);

  rowcount := SQL%ROWCOUNT;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_BULK_INS>

  RETURN rowcount;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
END bulk_ins;

FUNCTION upd (rv IN rvtype) RETURN rowtype IS
  lr        rvtype := rv;
  r         rowtype;
  error_msg VARCHAR2(32767);
BEGIN

  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
  assert(rv.#col# IS NOT NULL, '#col# cannot be null', scope);~
  <%END>

  error_msg := val (rv => rv);

  IF error_msg IS NOT NULL THEN
    UTIL.raise_error(error_msg);
  END IF;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_UPD>

  UPDATE #table# x
  SET    <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY>
         x.#col#... = lr.#col#~
         x.#col#... = UTIL.num_val(lr.#col#){NUMBER}~
         x.#col#... = UTIL.date_val(lr.#col#){DATE}~
         x.#col#... = UTIL.datetime_val(lr.#col#){DATETIME}~
         x.#col#... = UTIL.timestamp_val(lr.#col#){TIMESTAMP}~
         x.#col#... = UTIL.timestamp_tz_val(lr.#col#){TIMESTAMP_TZ}}~
        ,<%END>
  WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
         x.#col#... = lr.#col#~
         x.#COL#... = lr.#col#{ROWID}~
  AND    <%END>
  RETURNING
         <%COLUMNS INCLUDING VIRTUAL,ROWID>
         #col#~
         #COL#{ROWID}~
        ,<%END>
  INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
         r.#col#~
        ,<%END>;

  IF SQL%NOTFOUND THEN
    RAISE UTIL.lost_update;
  END IF;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_UPD>

  RETURN r;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_ref_con_violation (scope, params);
  WHEN UTIL.lost_update THEN
    lost_upd (rv => rv);
END upd;

FUNCTION bulk_upd (arr IN rvarraytype) RETURN NUMBER IS
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN

  bulk_val(arr);

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_BULK_UPD>

  FORALL i IN INDICES OF arr
    UPDATE #table# x
    SET    <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY>
           x.#col#... = lr(i).#col#~
           x.#col#... = UTIL.num_val(lr(i).#col#){NUMBER}~
           x.#col#... = UTIL.date_val(lr(i).#col#){DATE}~
           x.#col#... = UTIL.datetime_val(lr(i).#col#){DATETIME}~
           x.#col#... = UTIL.timestamp_val(lr(i).#col#){TIMESTAMP}~
           x.#col#... = UTIL.timestamp_tz_val(lr(i).#col#){TIMESTAMP_TZ}~
          ,<%END>
    WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
           x.#col#... = lr(i).#col#~
           x.#COL#... = lr(i).#col#{ROWID}~
    AND    <%END>;

  rowcount := SQL%ROWCOUNT;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_BULK_UPD>

  RETURN rowcount;
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    UTIL.raise_dup_val_on_index (scope, params);
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_ref_con_violation (scope, params);
END bulk_upd;

PROCEDURE del (rv IN rvtype) IS
  lr rvtype := rv;
BEGIN

  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
  assert(rv.#col# IS NOT NULL, '#col# cannot be null', scope);~
  <%END>

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_DEL>

  DELETE #table# x
  WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
         x.#col#... = lr.#col#~
         x.#COL#... = lr.#col#{ROWID}~
  AND    <%END>;

  IF SQL%NOTFOUND THEN
    RAISE UTIL.lost_update;
  END IF;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_DEL>

EXCEPTION
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_del_ref_con_violation (scope, params);
  WHEN UTIL.lost_update THEN
    lost_upd (rv => rv);
END del;

FUNCTION bulk_del (arr IN rvarraytype) RETURN NUMBER IS
  lr       rvarraytype := arr;
  rowcount NUMBER;
BEGIN

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_PRE_BULK_DEL>

  FORALL i IN INDICES OF arr
    DELETE #table# x
    WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
           x.#col#... = lr(i).#col#~
           x.#COL#... = lr(i).#col#{ROWID}
    AND    <%END>;

  rowcount := SQL%ROWCOUNT;

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_POST_BULK_DEL>

  RETURN rowcount;
EXCEPTION
  WHEN UTIL.ref_constraint_violation THEN
    UTIL.raise_del_ref_con_violation (scope, params);
END bulk_del;

-- convert an rvtype to a rowtype, no validation (exceptions may be raised on
-- datatype conversion errors), no audit columns
FUNCTION to_rowtype (rv IN rvtype) RETURN rowtype IS
  r      rowtype;
BEGIN

  <%COLUMNS EXCLUDING AUDIT>
  r.#col#... := rv.#col#;~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.DATE_FORMAT);{DATE}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  r.#col#... := TO_CHAR(rv.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  r.#col#... := rv.#col#;{ROWID}~
  <%END>

  RETURN r;
END to_rowtype;

-- convert a rowtype to an rvtype
FUNCTION to_rvtype (r IN rowtype) RETURN rvtype IS
  rv     rvtype;
BEGIN

  <%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
  rv.#col#... := r.#col#;~
  rv.#col#... := UTIL.date_val(r.#col#);{DATE}~
  rv.#col#... := UTIL.datetime_val(r.#col#);{DATETIME}~
  rv.#col#... := UTIL.timestamp_val(r.#col#);{TIMESTAMP}~
  rv.#col#... := UTIL.timestamp_tz_val(r.#col#);{TIMESTAMP_TZ}~
  rv.#col#... := CASE WHEN r.repeat IS NOT NULL THEN 'Y' END;{EVENTS.REPEAT_IND}~
  rv.#col#... := r.#col#;{ROWID}~
  <%END>

  RETURN rv;
END to_rvtype;

FUNCTION get (<%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
              #col#... IN #table#.#col#%TYPE~
              #col#... IN #table#.#col#%TYPE := NULL{VERSION_ID}~
              #col#... IN VARCHAR2{ROWID}~
             ,<%END>
             ,as_at   IN TIMESTAMP := NULL) RETURN rowtype IS
  r       rowtype;
BEGIN

  IF <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>#col# IS NOT NULL~
  OR <%END> THEN
  
    IF as_at IS NOT NULL THEN

      SELECT <%COLUMNS INCLUDING VIRTUAL>
             x.#col#~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL>
             r.#col#~
            ,<%END>
      FROM   #table# AS OF TIMESTAMP as_at x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.#COL#... = get.#col#{ROWID}~
      AND    <%END>;

    ELSIF version_id IS NOT NULL THEN
    
      SELECT <%COLUMNS INCLUDING VIRTUAL>
             x.#col#~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL>
             r.#col#~
            ,<%END>
      FROM   #journal# x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.#COL#... = get.#col#{ROWID}~
      AND    <%END>;
    
    ELSE
  
      SELECT <%COLUMNS INCLUDING VIRTUAL,ROWID>
             x.#col#~
             x.#COL#{ROWID}~
            ,<%END>
      INTO   <%COLUMNS INCLUDING VIRTUAL,ROWID>
             r.#col#~
            ,<%END>
      FROM   #table# x
      WHERE  <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
             x.#col#... = get.#col#~
             x.#COL#... = get.#col#{ROWID}~
      AND    <%END>;

    END IF;

  ELSE

    -- set up default record
    <%COLUMNS ONLY DEFAULT_VALUE EXCLUDING GENERATED,SURROGATE_KEY>
    r.#col#... := #DATA_DEFAULT#;~
    NULL;{NONE}~
    <%END>

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_SET_DEFAULT>

  END IF;

  RETURN r;
END get;

FUNCTION copy (r IN rowtype) RETURN rowtype IS
  nr     rowtype;
BEGIN
  
  nr := r;

  <%COLUMNS ONLY GENERATED,SURROGATE_KEY,ROWID,IDENTITY>
  nr.#col#... := NULL;~
  <%END>
  <%COLUMNS EXCLUDING GENERATED,SURROGATE_KEY>
  nr.title           := SUBSTR(nr.#col# || ' (copy)', 1, #MAXLEN#);{EVENTS.TITLE}~
  nr.event_type      := SUBSTR(nr.#col# || '_COPY', 1, #MAXLEN#);{EVENT_TYPES.EVENT_TYPE}~
  nr.name            := SUBSTR(nr.#col# || ' (copy)', 1, #MAXLEN#);{EVENT_TYPES.NAME}~
  nr.name            := SUBSTR(nr.#col# || ' (copy)', 1, #MAXLEN#);{HOSTS.NAME}~
  nr.name            := SUBSTR(nr.#col# || ' (copy)', 1, #MAXLEN#);{VENUES.NAME}~
  nr.name            := SUBSTR(nr.#col# || ' (copy)', 1, #MAXLEN#);{EMPS.NAME}~
  ~
  <%END>

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_COPY>

  RETURN nr;
END copy;

FUNCTION to_string
  (r   IN rowtype
  ,sep IN VARCHAR2 := '|'
  ) RETURN CLOB IS
  digest CLOB;
BEGIN

<%IF DBMS_CRYPTO>
  <%COLUMNS EXCLUDING GENERATED>
  digest := digest || sep || r.#col#;~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATE_FORMAT);{DATE}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  digest := digest || sep || DBMS_CRYPTO.hash(src => r.#col#, typ => DBMS_CRYPTO.HASH_MD5);{BLOB}~
  digest := digest || sep || DBMS_CRYPTO.hash(src => UTL_RAW.cast_to_raw(r.#col#), typ => DBMS_CRYPTO.HASH_MD5);{CLOB}~
  <%END>
<%ELSE>
  <%COLUMNS EXCLUDING GENERATED,LOBS>
  digest := digest || sep || r.#col#;~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATE_FORMAT);{DATE}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.DATETIME_FORMAT);{DATETIME}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_FORMAT);{TIMESTAMP}~
  digest := digest || sep || TO_CHAR(r.#col#, UTIL.TIMESTAMP_TZ_FORMAT);{TIMESTAMP_TZ}~
  <%END>
<%END IF>

  RETURN digest;
END to_string;
<%IF DBMS_CRYPTO>
FUNCTION hash (r IN rowtype) RETURN VARCHAR2 IS
  digest CLOB;
  ret    RAW(2000);
BEGIN

  digest := to_string(r => r, sep => '|');

  ret := DBMS_CRYPTO.hash(digest, DBMS_CRYPTO.hash_sh1);

  RETURN ret;
END hash;
<%END IF>

<%INCLUDE #TEMPLATE#.TAPI_PACKAGE_BODY_METHODS>

-- may be used to disable and re-enable the journal trigger for this session
PROCEDURE disable_journal_trigger IS
BEGIN
<%IF SECURITY_CONTEXT>
  SECURITY.disable_journal_trigger('#TRIGGER#');
<%ELSE>
  g_trigger_disabled := TRUE;
<%END IF>
END disable_journal_trigger;

PROCEDURE enable_journal_trigger IS
BEGIN
<%IF SECURITY_CONTEXT>
  SECURITY.enable_journal_trigger('#TRIGGER#');
<%ELSE>
  g_trigger_disabled := FALSE;
<%END IF>
END enable_journal_trigger;

FUNCTION journal_trigger_enabled RETURN BOOLEAN IS
  ret    BOOLEAN;
BEGIN
<%IF SECURITY_CONTEXT>
  ret := SYS_CONTEXT('#CONTEXT#','#TRIGGER#') IS NULL;
<%ELSE>
  ret := NOT NVL(g_trigger_disabled, FALSE);
<%END IF>
  RETURN ret;
END journal_trigger_enabled;

END #TAPI#;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE APEXAPI_PACKAGE_SPEC>
CREATE OR REPLACE PACKAGE #APEXAPI# AS
/*******************************************************************************
 Apex API for #table#
 #SYSDATE# - Generated by #USER#
*******************************************************************************/

/********************** TODO: DELETE THIS MESSAGE ******************************
 This is just a generated starting point for this API. It needs to be customised
 for the specific requirements of the application.
*******************************************************************************/

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_SPEC_DEC>

-- page load process
PROCEDURE load;

-- single-record page validation
PROCEDURE val;

-- validate the record but don't record failures as errors; instead, return a
-- list of the errors as "warnings" only
FUNCTION errors_as_warnings RETURN VARCHAR2;

-- multi-record page validation
PROCEDURE val_row
  (rv               IN #TAPI#.rvtype
  ,region_static_id IN VARCHAR2);

-- page submit process
PROCEDURE process;

-- tabular form process row
PROCEDURE apply_mr (rv IN #TAPI#.rvtype);

-- Interactive Grid process row
PROCEDURE apply_ig (rv IN #TAPI#.rvtype);

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_SPEC_METHODS>

-- The following are code samples to copy-and-paste into Apex, not intended to
-- be compiled here.
$if false $then

-- Suggested query for Tabular Form
SELECT <%COLUMNS INCLUDING ROWID>
       x.#col#~
       x.#COL# AS p_#col#{ROWID}~
      ,<%END>
FROM   #table# x

-- Put this in the Tabular Form validation "PL/SQL Function (returning Error
-- Text)" For Each Row:
#APEXAPI#.val_row (rv =>
  #TAPI#.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
     #col#... => :#COL#~
     #col#... => :P_#COL#{ROWID}~
    ,<%END>
    )
  ,region_static_id => '#table#');
RETURN null;

-- Put this in a Tabular Form process:
#APEXAPI#.apply_mr (rv =>
  #TAPI#.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
     #col#... => :#COL#~
     #col#... => :P_#COL#{ROWID}~
    ,<%END>
    ));

-- Put this in an Interactive Grid validation "PL/SQL Function (returning Error
-- Text)" For Created and Modified Rows
RETURN #TAPI#.val (rv =>
  #TAPI#.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING EVENTS.REPEAT_IND>
     #col#... => :#COL#~
    ,<%END>
    ));

-- Put this in an "Interactive Grid - Automatic Row Processing (DML)" process
-- with Target Type = PL/SQL Code
#APEXAPI#.apply_ig (rv =>
  #TAPI#.rv
    (<%COLUMNS EXCLUDING AUDIT INCLUDING ROWID,EVENTS.REPEAT_IND>
     #col#... => :#COL#~
    ,<%END>
    ));

$end

END #APEXAPI#;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE APEXAPI_PACKAGE_BODY>
CREATE OR REPLACE PACKAGE BODY #APEXAPI# AS
/*******************************************************************************
 Table API for #table#
 #SYSDATE# - Generated by #USER#
*******************************************************************************/

/********************** TODO: DELETE THIS MESSAGE ******************************
 This is just a generated starting point for this API. It needs to be customised
 for the specific requirements of the application.
*******************************************************************************/

scope_prefix constant varchar2(31) := lower($$plsql_unit) || '.';

-- column name constants
<%COLUMNS INCLUDING ROWID,EVENTS.REPEAT_IND,EVENTS.START_DT_TIME,EVENTS.END_DT_TIME,EVENTS.EVENT_IDENT>
#COL#...   CONSTANT VARCHAR2(30) := '#COL#';~
P_#COL#... CONSTANT VARCHAR2(30) := '#COL#';{ROWID}~
<%END>

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_BODY_DEC>

-- Note: if the record is identified by ROWID it's the caller's responsibility
-- to maintain the Pn_ROWID item value.
PROCEDURE apex_set (r IN #TAPI#.rowtype) IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
BEGIN

  <%COLUMNS INCLUDING VIRTUAL,ROWID EXCLUDING LOBS INCLUDING EVENTS.REPEAT_IND>
  sv(p||#COL#,...   r.#col#);~
  sd(p||#COL#,...   r.#col#);{DATE}~
  sd(p||#COL#,...   r.#col#);{DATETIME}~
  st(p||#COL#,...   r.#col#);{TIMESTAMP}~
  st(p||#COL#,...   r.#col#);{TIMESTAMP_TZ}~
  sd(p||START_DT,          r.start_dt, UTIL.DATE_FORMAT);
  sv(p||START_DT_TIME,     TO_CHAR(r.start_dt, UTIL.TIME12H_FORMAT));{EVENTS.START_DT}~
  sd(p||END_DT,            r.end_dt, UTIL.DATE_FORMAT);
  sv(p||END_DT_TIME,       TO_CHAR(r.end_dt, UTIL.TIME12H_FORMAT));{EVENTS.END_DT}~
  sv(p||REPEAT_IND,        CASE WHEN r.repeat IS NOT NULL THEN 'Y' END);{EVENTS.REPEAT_IND}~
  sv(p||P_#COL#,... r.#col#);{ROWID}~
  <%END>
  
<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_APEX_SET>

END apex_set;

FUNCTION apex_get_pk RETURN #TAPI#.rvtype IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     #TAPI#.rvtype;
BEGIN

  IF APEX_APPLICATION.g_request = 'COPY' THEN

    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    rv.#col#... := v(p||'COPY_'||#COL#);~
    rv.#col#... := v(p||'COPY_#COL#');{ROWID}~
    <%END>

    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    assert(rv.#col# IS NOT NULL, p||'COPY_'||#COL#||' cannot be null', scope);~
    assert(rv.#col# IS NOT NULL, p||'COPY_#COL# cannot be null', scope);{ROWID}~
    <%END>

  ELSE

    <%COLUMNS ONLY SURROGATE_KEY,VERSION_ID INCLUDING ROWID>
    rv.#col#... := v(p||#COL#);~
    rv.#col#... := nv(p||#COL#);{ID}~
    rv.#col#... := v(p||P_#COL#);{ROWID}~
    <%END>

  END IF;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_APEX_GET_PK>

  RETURN rv;
END apex_get_pk;

FUNCTION apex_get RETURN #TAPI#.rvtype IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     #TAPI#.rvtype;
  r      #TAPI#.rowtype;
BEGIN

  rv := apex_get_pk;
  
  r := #TAPI#.get(rv => rv);
  
  rv := #TAPI.to_rvtype(r => r);

  <%COLUMNS EXCLUDING AUDIT,LOBS INCLUDING ROWID>
  rv.#col#... := v(p||#COL#);~
  rv.#col#... := nv(p||#COL#);{ID}~
  rv.#col#... := v(p||#COL#) || ' ' || v(p||START_DT_TIME);{EVENTS.START_DT}~
  rv.#col#... := v(p||#COL#) || CASE WHEN v(p||#COL#) IS NOT NULL THEN ' ' || v(p||END_DT_TIME) END;{EVENTS.END_DT}~
  rv.#col#... := CASE WHEN rv.repeat_ind = 'Y' THEN v(p||#COL#) END;{EVENTS.REPEAT}~
  rv.#col#... := CASE WHEN rv.repeat_ind = 'Y' THEN v(p||#COL#) END;{EVENTS.REPEAT_INTERVAL}~
  rv.#col#... := CASE WHEN rv.repeat_ind = 'Y' THEN v(p||#COL#) END;{EVENTS.REPEAT_UNTIL}~
  rv.#col#... := v(p||P_#COL#);{ROWID}~
  <%END>

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_APEX_GET>
  
  RETURN rv;
END apex_get;

/*******************************************************************************
                               PUBLIC INTERFACE
*******************************************************************************/

PROCEDURE load IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     #TAPI#.rvtype;
  r      #TAPI#.rowtype;
BEGIN

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Reporting<%END IF>);

  rv := apex_get_pk;
  r := #TAPI#.get (<%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
                   #col#... => rv.#col#~
                  ,<%END>);

  IF APEX_APPLICATION.g_request = 'COPY' THEN

    r := #TAPI#.copy(r);
    <%IF ROWID>UTIL.sv(p||P_ROWID,'');<%END IF>

  END IF;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_LOAD>

  apex_set (r => r);

END load;

PROCEDURE val IS
  p             VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv            #TAPI#.rvtype;
  dummy         VARCHAR2(32767);
  item_name_map UTIL.str_map;
BEGIN

  IF APEX_APPLICATION.g_request = 'CREATE'
  OR APEX_APPLICATION.g_request LIKE 'SAVE%' THEN

    rv := apex_get;

    --If any page item does not match the column name, add it here so that
    --error messages are associated with the apex item:
    --item_name_map(COLUMN) := p || 'ITEMNAME';

    UTIL.pre_val
      (label_map     => #TAPI#.label_map
      ,item_name_map => item_name_map);

    dummy := #TAPI#.val (rv => rv);

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_VAL>

    UTIL.post_val;

  END IF;

END val;

FUNCTION errors_as_warnings RETURN VARCHAR2 IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     #TAPI#.rvtype;
  arr    UTIL.msg_array;
  buf    VARCHAR2(32767);
BEGIN

  rv := apex_get;

  IF #TAPI#.val (rv => rv) IS NOT NULL THEN
    buf := UTIL.errors_list;
  END IF;

  RETURN buf;
END errors_as_warnings;

PROCEDURE val_row
  (rv               IN #TAPI#.rvtype
  ,region_static_id IN VARCHAR2
  ) IS
  dummy            VARCHAR2(32767);
  column_alias_map UTIL.str_map;
BEGIN

  --If any column alias is different to the column name, assign it here so that
  --error messages are associated with the tabular form column:
  --column_alias_map(COLUMN) := 'ALIAS';

  UTIL.pre_val_row
    (label_map        => #TAPI#.label_map
    ,region_static_id => region_static_id
    ,column_alias_map => column_alias_map);

  dummy := #TAPI#.val (rv => rv);

  UTIL.post_val;

END val_row;

PROCEDURE process IS
  p      VARCHAR2(10) := 'P' || UTIL.apex_page_id || '_';
  rv     #TAPI#.rvtype;
  r      #TAPI#.rowtype;
BEGIN

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  CASE
  WHEN APEX_APPLICATION.g_request = 'CREATE' THEN

    rv := apex_get;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_PRE_INS>

    r := #TAPI#.ins (rv => rv);

    apex_set (r => r);

    UTIL.success('#Entity# created.');

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_POST_INS>

  WHEN APEX_APPLICATION.g_request LIKE 'SAVE%' THEN

    rv := apex_get;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_PRE_UPD>

    r := #TAPI#.upd (rv => rv);

    apex_set (r => r);
    UTIL.success('#Entity# updated.'
      || CASE WHEN APEX_APPLICATION.g_request = 'SAVE_COPY' THEN ' Ready to create new #entity#.' END);

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_POST_UPD>

  WHEN APEX_APPLICATION.g_request = 'DELETE' THEN

    rv := apex_get_pk;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_PRE_DEL>

    #TAPI#.del (rv => rv);

    UTIL.clear_page_cache;

    UTIL.success('#Entity# deleted.');

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_POST_DEL>

  ELSE
    NULL;
  END CASE;

END process;

PROCEDURE apply_mr (rv IN #TAPI#.rvtype) IS
  r      #TAPI#.rowtype;
BEGIN

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  IF APEX_APPLICATION.g_request = 'MULTI_ROW_DELETE' THEN

    IF v('APEX$ROW_SELECTOR') = 'X' THEN
      #TAPI#.del (rv => rv);
    END IF;

  ELSE

    CASE v('APEX$ROW_STATUS')
    WHEN 'C' THEN

      r := #TAPI#.ins (rv => rv);

    WHEN 'U' THEN

      r := #TAPI#.upd (rv => rv);

    ELSE
      NULL;
    END CASE;

  END IF;

END apply_mr;

PROCEDURE apply_ig (rv IN #TAPI#.rvtype) IS
  r      #TAPI#.rowtype;
BEGIN

  UTIL.check_authorization(<%IF EVENT_TYPES>SECURITY.Administrator<%ELSE>SECURITY.Operator<%END IF>);

  CASE v('APEX$ROW_STATUS')
  WHEN 'I' THEN

    r := #TAPI#.ins (rv => rv);
    
    -- Interactive Grid needs the new PK in order to find the new record
    <%COLUMNS ONLY SURROGATE_KEY INCLUDING ROWID>
    sv('#COL#',... r.#col#);~
    sv('#COL#',... r.#col#);{ROWID}~
    <%END>

  WHEN 'U' THEN

    r := #TAPI#.upd (rv => rv);

  WHEN 'D' THEN

    #TAPI#.del (rv => rv);

  END CASE;

END apply_ig;

<%INCLUDE #TEMPLATE#.APEXAPI_PACKAGE_BODY_METHODS>

END #APEXAPI#;
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_INSERT>
SELECT 'INTO #TABLE#(<%COLUMNS #columnspec#>#col#~,<%END>) VALUES(<%COLUMNS #columnspec#>
'''||REPLACE(REPLACE(#col#,'''',''''''),CHR(38),'''||CHR(38)||''')||'''~
'||NVL(TO_CHAR(#col#),'NULL')||'{NUMBER}~
'||NVL(TO_CHAR(#col#),'NULL')||'{ID}~
'||CASE WHEN #col# IS NOT NULL THEN 'DATE '''||TO_CHAR(#col#,'YYYY-MM-DD')||'''' ELSE 'NULL' END||'{DATE}~
'||CASE WHEN #col# IS NOT NULL THEN 'TO_DATE('''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS')||''',''YYYY-MM-DD HH24:MI:SS'')' ELSE 'NULL' END||'{DATETIME}~
'||CASE WHEN #col# IS NOT NULL THEN 'TIMESTAMP '''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF')||'''' ELSE 'NULL' END||'{TIMESTAMP}~
'||CASE WHEN #col# IS NOT NULL THEN 'TIMESTAMP '''||TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM')||'''' ELSE 'NULL' END||'{TIMESTAMP_TZ}~
,<%END>
)' FROM #TABLE# t ORDER BY 1
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_CSV_HEADER>
<%COLUMNS #columnspec#>#HEADER#~,<%END>
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

<%TEMPLATE EXPORT_CSV>
SELECT <%COLUMNS #columnspec#>
CASE WHEN INSTR(#col#,',')>0 OR INSTR(#col#,'"')>0 OR INSTR(#col#,CHR(10))>0 THEN '"'||REPLACE(#col#,'"','""')||'"' ELSE #col# END~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){NUMBER}~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){BINARY_FLOAT}~
TO_CHAR(#col#,'fm999990'||CASE WHEN #col#!=TRUNC(#col#) THEN 'D099999' END){BINARY_DOUBLE}~
TO_CHAR(#col#,'fm999990'){ID}~
TO_CHAR(#col#,'YYYY-MM-DD'){DATE}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS'){DATETIME}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF'){TIMESTAMP}~
TO_CHAR(#col#,'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM'){TIMESTAMP_TZ}~
||','||<%END> FROM #TABLE# t ORDER BY 1
<%END TEMPLATE>

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%--

$end
END TEMPLATES;
/